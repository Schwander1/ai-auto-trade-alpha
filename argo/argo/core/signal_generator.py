#!/usr/bin/env python3
"""Alpine Analytics - Production Signal Generator"""
import sys
import json
import logging
import os
from datetime import datetime
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent))

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("SignalGenerator")

def _get_config_path():
    """Get config path for dev or production"""
    # Check environment variable first
    config_path = os.getenv('ARGO_CONFIG_PATH')
    if config_path and os.path.exists(config_path):
        return config_path
    
    # Check production path
    prod_path = Path('/root/argo-production/config.json')
    if prod_path.exists():
        return str(prod_path)
    
    # Check dev path (argo/config.json)
    dev_path = Path(__file__).parent.parent.parent / 'config.json'
    if dev_path.exists():
        return str(dev_path)
    
    # Fallback to production path (will fail gracefully if not exists)
    return '/root/argo-production/config.json'

def generate_signal(symbol):
    """
    Generate trading signal using weighted multi-source consensus
    
    Args:
        symbol (str): Stock symbol (e.g., 'AAPL', 'NVDA')
    
    Returns:
        dict: Signal with action, confidence, entry/target/stop prices
    """
    try:
        # Load config using environment-aware path resolution
        config_path = _get_config_path()
        with open(config_path) as f:
            config = json.load(f)
        
        min_confidence = config['trading']['min_confidence']
        profit_target = config['trading']['profit_target']
        stop_loss = config['trading']['stop_loss']
        
        # For now, use simple logic (you already have signal_tracker.py working)
        # This is a placeholder that will be enhanced with your data sources
        
        # Simulated signal (replace with actual multi-source logic)
        import random
        
        # Get current price (use your data aggregator)
        entry_price = 225.50  # Placeholder - fetch real price
        
        # Generate weighted consensus
        confidence = random.uniform(75, 95)  # Placeholder
        action = "LONG" if confidence > 87 else None
        
        if not action:
            return None
        
        signal = {
            'signal_id': None,  # Will be generated by SignalTracker
            'symbol': symbol,
            'action': action,
            'entry_price': entry_price,
            'target_price': entry_price * (1 + profit_target),
            'stop_price': entry_price * (1 - stop_loss),
            'confidence': confidence,
            'strategy': 'weighted_consensus',
            'asset_type': 'stock',
            'data_source': 'alpine_analytics',
            'timestamp': datetime.utcnow().isoformat(),
            'sources_used': ['massive', 'alpha_vantage', 'sonar', 'xai']
        }
        
        logger.info(f"✅ Generated signal for {symbol}: {action} @ ${entry_price:.2f} (confidence: {confidence:.1f}%)")
        
        return signal if confidence >= min_confidence else None
        
    except Exception as e:
        logger.error(f"❌ Error generating signal for {symbol}: {e}")
        return None

if __name__ == "__main__":
    # Test
    signal = generate_signal('AAPL')
    if signal:
        print(json.dumps(signal, indent=2))
