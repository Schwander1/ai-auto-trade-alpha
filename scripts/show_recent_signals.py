#!/usr/bin/env python3
"""
Show Recent Signals - Monitor Signal Generation
Displays the most recent signals generated by the system
"""
import sqlite3
import sys
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Optional

def find_signal_database() -> Optional[Path]:
    """Find the signal database file"""
    # Try unified database first (production)
    db_paths = [
        Path("/root/argo-production") / "data" / "signals_unified.db",
        Path("/root/argo-production-green") / "data" / "signals_unified.db",
        Path("/root/argo-production-blue") / "data" / "signals_unified.db",
        Path(__file__).parent.parent / "data" / "signals_unified.db",
        Path(__file__).parent.parent / "argo" / "data" / "signals_unified.db",
        Path(__file__).parent.parent / "data" / "signals.db",
        Path(__file__).parent.parent / "argo" / "data" / "signals.db",
    ]

    for db_path in db_paths:
        if db_path.exists():
            return db_path

    return None

def get_recent_signals(limit: int = 20) -> List[Dict]:
    """Get recent signals from database"""
    db_path = find_signal_database()

    if not db_path:
        print("âŒ Signal database not found")
        print("   Searched paths:")
        for path in [
            "/root/argo-production/data/signals_unified.db",
            "data/signals_unified.db",
            "argo/data/signals_unified.db",
        ]:
            print(f"   - {path}")
        return []

    try:
        conn = sqlite3.connect(str(db_path), timeout=10.0)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        # Try to get table schema first
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='signals'")
        if not cursor.fetchone():
            print(f"âŒ Signals table not found in {db_path}")
            conn.close()
            return []

        # Get recent signals
        cursor.execute("""
            SELECT
                signal_id,
                symbol,
                action,
                entry_price,
                confidence,
                timestamp,
                strategy,
                regime,
                order_id,
                outcome
            FROM signals
            ORDER BY timestamp DESC
            LIMIT ?
        """, (limit,))

        signals = []
        for row in cursor.fetchall():
            # Get column names
            columns = [desc[0] for desc in cursor.description]
            row_dict = {col: row[col] for col in columns}

            signals.append({
                'signal_id': row_dict.get('signal_id'),
                'symbol': row_dict.get('symbol'),
                'action': row_dict.get('action'),
                'entry_price': row_dict.get('entry_price'),
                'confidence': row_dict.get('confidence'),
                'timestamp': row_dict.get('timestamp'),
                'strategy': row_dict.get('strategy', 'N/A'),
                'regime': row_dict.get('regime', 'N/A'),
                'order_id': row_dict.get('order_id'),
                'outcome': row_dict.get('outcome', 'N/A')
            })

        conn.close()
        return signals

    except sqlite3.Error as e:
        print(f"âŒ Database error: {e}")
        return []
    except Exception as e:
        print(f"âŒ Error: {e}")
        return []

def format_timestamp(timestamp: str) -> str:
    """Format timestamp for display"""
    try:
        dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
        return dt.strftime('%Y-%m-%d %H:%M:%S UTC')
    except:
        return timestamp

def display_signals(signals: List[Dict]):
    """Display signals in a formatted table"""
    if not signals:
        print("\nâš ï¸  No recent signals found")
        return

    print(f"\nğŸ“Š Recent Signals (Last {len(signals)} signals)")
    print("=" * 120)
    print(f"{'Time':<20} {'Symbol':<10} {'Action':<8} {'Price':<12} {'Confidence':<12} {'Regime':<12} {'Order ID':<15} {'Outcome':<10}")
    print("-" * 120)

    for signal in signals:
        timestamp = format_timestamp(signal['timestamp'])
        symbol = signal['symbol']
        action = signal['action']
        price = f"${signal['entry_price']:.2f}" if signal['entry_price'] else "N/A"
        confidence = f"{signal['confidence']:.1f}%" if signal['confidence'] else "N/A"
        regime = signal.get('regime', 'N/A')
        order_id = signal.get('order_id', 'N/A') or 'N/A'
        outcome = signal.get('outcome', 'N/A') or 'N/A'

        # Color coding for action
        action_display = action
        if action == 'BUY' or action == 'LONG':
            action_display = f"ğŸŸ¢ {action}"
        elif action == 'SELL' or action == 'SHORT':
            action_display = f"ğŸ”´ {action}"
        elif action == 'NEUTRAL':
            action_display = f"âšª {action}"

        print(f"{timestamp:<20} {symbol:<10} {action_display:<10} {price:<12} {confidence:<12} {regime:<12} {order_id:<15} {outcome:<10}")

    print("=" * 120)

    # Summary statistics
    if signals:
        total = len(signals)
        buy_count = sum(1 for s in signals if s['action'] in ['BUY', 'LONG'])
        sell_count = sum(1 for s in signals if s['action'] in ['SELL', 'SHORT'])
        neutral_count = sum(1 for s in signals if s['action'] == 'NEUTRAL')
        avg_confidence = sum(s['confidence'] for s in signals if s['confidence']) / total if total > 0 else 0
        executed_count = sum(1 for s in signals if s.get('order_id') and s['order_id'] != 'N/A')

        print(f"\nğŸ“ˆ Summary:")
        print(f"   Total Signals: {total}")
        print(f"   BUY/LONG: {buy_count} ({buy_count/total*100:.1f}%)")
        print(f"   SELL/SHORT: {sell_count} ({sell_count/total*100:.1f}%)")
        print(f"   NEUTRAL: {neutral_count} ({neutral_count/total*100:.1f}%)")
        print(f"   Avg Confidence: {avg_confidence:.1f}%")
        print(f"   Executed: {executed_count} ({executed_count/total*100:.1f}%)")

        # Show unique symbols
        symbols = set(s['symbol'] for s in signals)
        print(f"   Symbols: {', '.join(sorted(symbols))}")

def main():
    """Main function"""
    limit = 20
    if len(sys.argv) > 1:
        try:
            limit = int(sys.argv[1])
        except ValueError:
            print("Usage: python show_recent_signals.py [limit]")
            sys.exit(1)

    print("ğŸ” Querying signal database...")
    signals = get_recent_signals(limit)
    display_signals(signals)

if __name__ == "__main__":
    main()
