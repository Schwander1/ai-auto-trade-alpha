# Backend Rules (Argo/Alpine)

**Last Updated:** January 15, 2025  
**Version:** 2.0  
**Applies To:** Argo & Alpine Backend (Python/FastAPI)

---

## Overview

Backend-specific rules for Argo Trading Engine and Alpine Analytics Backend, focusing on Python, FastAPI, and trading system best practices.

---

## Code Style

### Python Standards
- **Style Guide:** PEP 8
- **Formatter:** Black (88-100 char line length)
- **Linter:** Ruff, mypy
- **Type Hints:** Required for all functions

### Naming Conventions
- **Functions:** `snake_case` with `verb_noun` pattern
- **Classes:** `PascalCase` with `Noun` or `NounVerb` pattern
- **Variables:** `snake_case` with descriptive names
- **Constants:** `UPPER_SNAKE_CASE`

---

## FastAPI Best Practices

### Endpoint Structure

```python
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel

router = APIRouter(prefix="/api/signals", tags=["signals"])

class SignalCreate(BaseModel):
    symbol: str
    confidence: float
    entry_price: float

@router.post("/", response_model=SignalResponse)
async def create_signal(
    signal: SignalCreate,
    current_user: User = Depends(get_current_user)
):
    """
    Create a new trading signal.
    
    - **symbol**: Stock symbol (e.g., "AAPL")
    - **confidence**: Signal confidence (0-100)
    - **entry_price**: Entry price in USD
    """
    try:
        result = await signal_service.create_signal(signal, current_user)
        return result
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Error creating signal: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
```

### Response Models
- **Rule:** Always define response models
- **Use:** Pydantic models for validation
- **Example:**
  ```python
  class SignalResponse(BaseModel):
      id: str
      symbol: str
      confidence: float
      entry_price: float
      created_at: datetime
      
      class Config:
          from_attributes = True
  ```

---

## Error Handling

### Exception Handling
```python
from fastapi import HTTPException

@router.get("/signals/{signal_id}")
async def get_signal(signal_id: str):
    try:
        signal = await signal_service.get_signal(signal_id)
        if not signal:
            raise HTTPException(status_code=404, detail="Signal not found")
        return signal
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Error fetching signal {signal_id}: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
```

### Custom Exceptions
```python
class SignalNotFoundError(Exception):
    """Raised when signal is not found."""
    pass

class InvalidSignalError(Exception):
    """Raised when signal data is invalid."""
    pass
```

---

## Database Operations

### SQLAlchemy Patterns

#### Session Management
```python
from sqlalchemy.orm import Session

def get_signal(db: Session, signal_id: str):
    return db.query(Signal).filter(Signal.id == signal_id).first()

def create_signal(db: Session, signal_data: dict):
    signal = Signal(**signal_data)
    db.add(signal)
    db.commit()
    db.refresh(signal)
    return signal
```

#### Query Optimization
- **Rule:** Avoid N+1 queries
- **Use:** Eager loading with `joinedload` or `selectinload`
- **Example:**
  ```python
  from sqlalchemy.orm import joinedload
  
  signals = db.query(Signal).options(
      joinedload(Signal.user)
  ).all()
  ```

### Parameterized Queries
- **Rule:** Always use parameterized queries
- **Never:** Concatenate SQL strings
- **Example:**
  ```python
  # BAD ❌
  query = f"SELECT * FROM signals WHERE symbol = '{symbol}'"
  
  # GOOD ✅
  query = "SELECT * FROM signals WHERE symbol = :symbol"
  result = db.execute(query, {"symbol": symbol})
  ```

---

## Async Operations

### Async/Await Pattern
```python
import asyncio
import aiohttp

async def fetch_market_data(symbol: str):
    async with aiohttp.ClientSession() as session:
        async with session.get(f"https://api.example.com/{symbol}") as response:
            return await response.json()

async def process_multiple_symbols(symbols: list[str]):
    tasks = [fetch_market_data(symbol) for symbol in symbols]
    return await asyncio.gather(*tasks)
```

### Database Async
```python
from sqlalchemy.ext.asyncio import AsyncSession

async def get_signal_async(db: AsyncSession, signal_id: str):
    result = await db.execute(
        select(Signal).where(Signal.id == signal_id)
    )
    return result.scalar_one_or_none()
```

---

## Logging

### Structured Logging
```python
import logging
import json

logger = logging.getLogger(__name__)

def log_signal_creation(signal_id: str, user_id: str, symbol: str):
    logger.info(
        "Signal created",
        extra={
            "signal_id": signal_id,
            "user_id": user_id,
            "symbol": symbol,
            "event": "signal_created"
        }
    )
```

### Log Levels
- **DEBUG:** Detailed information for debugging
- **INFO:** General informational messages
- **WARNING:** Warning messages
- **ERROR:** Error messages
- **CRITICAL:** Critical errors

---

## Trading System Specifics

### Signal Generation
```python
class SignalGenerationService:
    def __init__(self, consensus_engine: WeightedConsensusEngine):
        self.consensus_engine = consensus_engine
        self.trading_engine = None  # Initialize if auto_execute enabled
    
    async def generate_signal_for_symbol(self, symbol: str) -> Signal:
        # Generate signal using consensus engine
        signal = await self.consensus_engine.generate_signal(symbol)
        
        # Validate signal
        if not self._validate_signal(signal):
            raise InvalidSignalError("Signal validation failed")
        
        # Execute if auto_execute enabled
        if self.trading_engine and signal.confidence >= MIN_CONFIDENCE:
            await self.trading_engine.execute_signal(signal)
        
        return signal
```

### Risk Management
```python
def validate_trade(signal: Signal, account: Account) -> bool:
    # Check confidence threshold
    if signal.confidence < MIN_CONFIDENCE:
        return False
    
    # Check buying power
    required_capital = calculate_position_size(signal, account)
    if required_capital > account.buying_power * 0.95:
        return False
    
    # Check daily loss limit
    if account.daily_loss >= account.equity * DAILY_LOSS_LIMIT_PCT:
        return False
    
    return True
```

---

## API Security

### Authentication
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    token = credentials.credentials
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication credentials"
            )
        return get_user(user_id)
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials"
        )
```

### Rate Limiting
```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@router.post("/signals")
@limiter.limit("10/minute")
async def create_signal(request: Request, signal: SignalCreate):
    # Endpoint implementation
    pass
```

---

## Testing

### Unit Tests
```python
import pytest
from unittest.mock import Mock, patch

def test_calculate_position_size():
    balance = 10000.0
    confidence = 80.0
    risk_pct = 0.1
    
    result = calculate_position_size(balance, confidence, risk_pct)
    
    assert result == 800.0

@patch('alpaca.tradeapi.REST')
def test_execute_trade(mock_alpaca):
    mock_alpaca.return_value.submit_order.return_value = {"id": "123"}
    result = execute_trade(signal)
    assert result.order_id == "123"
```

### Integration Tests
```python
@pytest.mark.asyncio
async def test_signal_creation_flow(client):
    response = await client.post(
        "/api/signals",
        json={
            "symbol": "AAPL",
            "confidence": 85.0,
            "entry_price": 150.25
        },
        headers={"Authorization": f"Bearer {token}"}
    )
    assert response.status_code == 200
    assert response.json()["symbol"] == "AAPL"
```

---

## Performance Optimization

### Caching
```python
from functools import lru_cache
import redis

redis_client = redis.Redis(host='localhost', port=6379, db=0)

@lru_cache(maxsize=100)
def get_cached_signal(signal_id: str):
    return fetch_signal_from_db(signal_id)

async def get_signal_with_redis(signal_id: str):
    # Try Redis first
    cached = redis_client.get(f"signal:{signal_id}")
    if cached:
        return json.loads(cached)
    
    # Fallback to database
    signal = await get_signal_from_db(signal_id)
    redis_client.setex(
        f"signal:{signal_id}",
        3600,  # 1 hour TTL
        json.dumps(signal)
    )
    return signal
```

### Connection Pooling
```python
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

engine = create_engine(
    DATABASE_URL,
    poolclass=QueuePool,
    pool_size=10,
    max_overflow=20
)
```

---

## Related Rules

- [01_DEVELOPMENT.md](01_DEVELOPMENT.md) - Development practices
- [03_TESTING.md](03_TESTING.md) - Testing requirements
- [07_SECURITY.md](07_SECURITY.md) - Security practices
- [13_TRADING_OPERATIONS.md](13_TRADING_OPERATIONS.md) - Trading operations
- [14_MONITORING_OBSERVABILITY.md](14_MONITORING_OBSERVABILITY.md) - Monitoring and logging

